<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>parkour.mapreduce documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Parkour 0.3.4-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li><a href="parkour.conf.html"><span>parkour.conf</span></a></li><li><a href="parkour.cstep.html"><span>parkour.cstep</span></a></li><li><a href="parkour.fs.html"><span>parkour.fs</span></a></li><li><a href="parkour.graph.html"><span>parkour.graph</span></a></li><li><a href="parkour.io.avro.html"><span>parkour.io.avro</span></a></li><li><a href="parkour.io.cascading.html"><span>parkour.io.cascading</span></a></li><li><a href="parkour.io.dseq.html"><span>parkour.io.dseq</span></a></li><li><a href="parkour.io.dsink.html"><span>parkour.io.dsink</span></a></li><li><a href="parkour.io.dux.html"><span>parkour.io.dux</span></a></li><li><a href="parkour.io.mem.html"><span>parkour.io.mem</span></a></li><li><a href="parkour.io.mux.html"><span>parkour.io.mux</span></a></li><li><a href="parkour.io.nline.html"><span>parkour.io.nline</span></a></li><li><a href="parkour.io.seqf.html"><span>parkour.io.seqf</span></a></li><li><a href="parkour.io.text.html"><span>parkour.io.text</span></a></li><li class="current"><a href="parkour.mapreduce.html"><span>parkour.mapreduce</span></a></li><li><a href="parkour.reducers.html"><span>parkour.reducers</span></a></li><li><a href="parkour.tool.html"><span>parkour.tool</span></a></li><li><a href="parkour.wrapper.html"><span>parkour.wrapper</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="parkour.mapreduce.html#var-combiner%21"><span>combiner!</span></a></li><li><a href="parkour.mapreduce.html#var-counters-map"><span>counters-map</span></a></li><li><a href="parkour.mapreduce.html#var-job"><span>job</span></a></li><li><a href="parkour.mapreduce.html#var-keygroups"><span>keygroups</span></a></li><li><a href="parkour.mapreduce.html#var-keykeygroups"><span>keykeygroups</span></a></li><li><a href="parkour.mapreduce.html#var-keykeyvalgroups"><span>keykeyvalgroups</span></a></li><li><a href="parkour.mapreduce.html#var-keys"><span>keys</span></a></li><li><a href="parkour.mapreduce.html#var-keysgroups"><span>keysgroups</span></a></li><li><a href="parkour.mapreduce.html#var-keyvalgroups"><span>keyvalgroups</span></a></li><li><a href="parkour.mapreduce.html#var-keyvals"><span>keyvals</span></a></li><li><a href="parkour.mapreduce.html#var-mapper%21"><span>mapper!</span></a></li><li><a href="parkour.mapreduce.html#var-partitioner%21"><span>partitioner!</span></a></li><li><a href="parkour.mapreduce.html#var-reducer%21"><span>reducer!</span></a></li><li><a href="parkour.mapreduce.html#var-set-combiner"><span>set-combiner</span></a></li><li><a href="parkour.mapreduce.html#var-set-mapper"><span>set-mapper</span></a></li><li><a href="parkour.mapreduce.html#var-set-partitioner"><span>set-partitioner</span></a></li><li><a href="parkour.mapreduce.html#var-set-reducer"><span>set-reducer</span></a></li><li><a href="parkour.mapreduce.html#var-sink"><span>sink</span></a></li><li><a href="parkour.mapreduce.html#var-sink-as"><span>sink-as</span></a></li><li><a href="parkour.mapreduce.html#var-tac"><span>tac</span></a></li><li><a href="parkour.mapreduce.html#var-valgroups"><span>valgroups</span></a></li><li><a href="parkour.mapreduce.html#var-vals"><span>vals</span></a></li><li><a href="parkour.mapreduce.html#var-wrap-sink"><span>wrap-sink</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>parkour.mapreduce documentation</h2><pre class="doc"></pre><div class="public" id="var-combiner%21"><h3>combiner!</h3><div class="usage"><code>(combiner! conf var &amp; args)</code></div><pre class="doc">As per `reducer!`, but allocate and configure for the Hadoop combine step,
which may impact e.g. output types.</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L146">Source</a></div></div><div class="public" id="var-counters-map"><h3>counters-map</h3><div class="usage"><code>(counters-map counters)</code></div><pre class="doc">Translate job `counters` into nested Clojure map of strings to counts.
</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L214">Source</a></div></div><div class="public" id="var-job"><h3>job</h3><div class="usage"><code>(job)</code><code>(job conf)</code></div><pre class="doc">Return new Hadoop `Job` instance, optionally initialized with configuration
`conf`.</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L87">Source</a></div></div><div class="public" id="var-keygroups"><h3>keygroups</h3><div class="usage"><code>(keygroups context)</code></div><pre class="doc">Produce distinct keys from the tuples in `context`.
</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L29">Source</a></div></div><div class="public" id="var-keykeygroups"><h3>keykeygroups</h3><div class="usage"><code>(keykeygroups context)</code></div><pre class="doc">Produce pairs of distinct grouping keys and associated sequences of specific
keys from the tuples in `context`.</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L48">Source</a></div></div><div class="public" id="var-keykeyvalgroups"><h3>keykeyvalgroups</h3><div class="usage"><code>(keykeyvalgroups context)</code></div><pre class="doc">Produce pairs of distinct grouping keys and associated sequences of specific
keys and values from the tuples in `context`.</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L43">Source</a></div></div><div class="public" id="var-keys"><h3>keys</h3><div class="usage"><code>(keys context)</code></div><pre class="doc">Produce keys only from the tuples in `context`.
</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L17">Source</a></div></div><div class="public" id="var-keysgroups"><h3>keysgroups</h3><div class="usage"><code>(keysgroups context)</code></div><pre class="doc">Produce sequences of specific keys associated with distinct grouping keys
from the tuples in `context`.</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L53">Source</a></div></div><div class="public" id="var-keyvalgroups"><h3>keyvalgroups</h3><div class="usage"><code>(keyvalgroups context)</code></div><pre class="doc">Produce pairs of distinct group keys and associated sequences of values from
the tuples in `context`.</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L38">Source</a></div></div><div class="public" id="var-keyvals"><h3>keyvals</h3><div class="usage"><code>(keyvals context)</code></div><pre class="doc">Produce pairs of keys and values from the tuples in `context`.
</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L25">Source</a></div></div><div class="public" id="var-mapper%21"><h3>mapper!</h3><div class="usage"><code>(mapper! conf var &amp; args)</code></div><pre class="doc">Allocate and return a new Parkour mapper class for `conf` as invoking `var`.
The `var` will be called during task-setup with the job `Configuration` and any
provided `args` (which must be EDN-serializable).  The `var` should return a
function of two arguments, which will be invoked with the task context and a
reducible collection of the `unwrap`ed input tuples.  It should return a
reducible collection of the output tuples, which will be automatically wrapped
to match the job-configured map ouput types.

If `var` has a truthy value for the `:parkour.mapreduce/raw` metadata key, then
Parkour will invoke the `var`-returned function with only the task context, and
will ignore any return value.</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L99">Source</a></div></div><div class="public" id="var-partitioner%21"><h3>partitioner!</h3><div class="usage"><code>(partitioner! conf var &amp; args)</code></div><pre class="doc">Allocate and return a new Parkour partitioner class for `conf` as invoking
`var`.  The `var` will be called during task-setup with the job `Configuration`
and any provided `args` (which must be EDN-serializable).  The `var` should
return a function of three arguments: an `unwrap`ed map-output key, an
`unwrap`ed map-output value, and an integral reduce-task count.  That function
will called for each map-output tuple, must return an integral value mod the
reduce-task count, and should be primitive-hinted as `OOLL`.

If `var` has a truthy value for the `:parkour.mapreduce/raw` metadata key, then
Parkour will invoke the `var`-returned partitioner function with the raw (not
unwrapped) tuple key and value objects.</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L152">Source</a></div></div><div class="public" id="var-reducer%21"><h3>reducer!</h3><div class="usage"><code>(reducer! conf var &amp; args)</code></div><pre class="doc">Allocate and return a new Parkour reducer class for `conf` as invoking `var`.
The `var` will be called during task-setup with the job `Configuration` and any
provided `args` (which must be EDN-serializable).  The `var` should return a
function of two arguments, which will be invoked with the task context and a
reducible collection of the `unwrap`ed input tuples.  It should return a
reducible collection of the output tuples, which will be automatically wrapped
to match the job-configured map ouput types.

If `var` has a truthy value for the `:parkour.mapreduce/raw` metadata key, then
Parkour will invoke the `var`-returned function with only the task context, and
will ignore any return value.</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L131">Source</a></div></div><div class="public" id="var-set-combiner"><h3>set-combiner</h3><div class="usage"><code>(set-combiner job cls)</code></div><pre class="doc">Set the combiner class for `job` to `cls`.
</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L175">Source</a></div></div><div class="public" id="var-set-mapper"><h3>set-mapper</h3><div class="usage"><code>(set-mapper job cls)</code></div><pre class="doc">Set the mapper class for `job` to `cls`.
</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L171">Source</a></div></div><div class="public" id="var-set-partitioner"><h3>set-partitioner</h3><div class="usage"><code>(set-partitioner job cls)</code></div><pre class="doc">Set the partitioner class for `job` to `cls`.
</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L183">Source</a></div></div><div class="public" id="var-set-reducer"><h3>set-reducer</h3><div class="usage"><code>(set-reducer job cls)</code></div><pre class="doc">Set the reducer class for `job` to `cls`.
</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L179">Source</a></div></div><div class="public" id="var-sink"><h3>sink</h3><div class="usage"><code>(sink sink coll)</code></div><pre class="doc">Emit all tuples from `coll` to `sink`.
</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L74">Source</a></div></div><div class="public" id="var-sink-as"><h3>sink-as</h3><div class="usage"><code>(sink-as kind coll)</code></div><pre class="doc">Annotate `coll` as containing values to sink as `kind`.  The `kind` may
either be a sinking function of two arguments (a sink and a collection) or a
keyword indicating a built-in sinking function.  Supported keywords are `:none`,
`:keys`, `:vals`, and `:keyvals`.</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L67">Source</a></div></div><div class="public" id="var-tac"><h3>tac</h3><div class="usage"><code>(tac conf)</code><code>(tac conf id)</code></div><pre class="doc">Return a new TaskAttemptContext instance using provided configuration `conf`
and task attempt ID `taid`.</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L207">Source</a></div></div><div class="public" id="var-valgroups"><h3>valgroups</h3><div class="usage"><code>(valgroups context)</code></div><pre class="doc">Produce sequences of values associated with distinct grouping keys from the
tuples in `context`.</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L33">Source</a></div></div><div class="public" id="var-vals"><h3>vals</h3><div class="usage"><code>(vals context)</code></div><pre class="doc">Produce values only from the tuples in `context`.
</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L21">Source</a></div></div><div class="public" id="var-wrap-sink"><h3>wrap-sink</h3><div class="usage"><code>(wrap-sink sink)</code><code>(wrap-sink ckey cval sink)</code></div><pre class="doc">Return new tuple sink which wraps keys and values as the types `ckey` and
`cval` respectively, which should be compatible with the key and value type of
`sink`.  Where they are not compatible, the type of the `sink` will be used
instead.  Returns a new tuple sink which wraps any sunk keys and values which
are not already of the correct type then sinks them to `sink`.</pre><div class="src-link"><a href="https://github.atl.damballa/rnd/parkour/blob/master/src/clojure/parkour/mapreduce.clj#L58">Source</a></div></div></div></body></html>